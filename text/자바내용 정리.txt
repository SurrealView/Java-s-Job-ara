1. 변수의 명명 규칙#
1. 대소문자가 구분되며 길이 제한이 없다.#
2. 예약어를 사용하면 안 된다.#
3. 숫자로 시작하면 안 된다.#
예) age1은 가능하지만 1age는 불가능 #
4. 특수문자는 ‘_’와 ‘$’만을 허용한다.# 
예) sh@rp는 불가능하지만 $harp는 가능 #
5. 여러 단어 이름은 단어의 첫 글자를 대문자로 한다.#
예) ageOfVampire, userName#


2.변수의 자동형변환#
 : 연산시 컴파일러가 자동으로 형이 변환하는 것을 의미한다.#
byte -> short -> int -> long -> float -> double#
char -> int #
단, byte와 short 자료형 값의 계산 결과는 무조건 int로 처리한다.#

4. 자동 형변환이 일어나는 경우#
- 작은 자료형에서 큰자료형으로 변환시#
- 정수는 실수로 자동형변환 된다.#
- 문자는 int로 자동 형변환된다.#
- boolean은 형변환 불가#

* 강제 형변환 #
 : 자료형으로 형변환을 해줄 수 있다. 데이터가 큰 자료형에서 작은 #
자료형으로 변경 시 데이터 손실이 있을 수 잇어 유의 해야 한다.#

ex) double temp;#
     int age = (int) temp;#


3. 자료형 크기#
----논리형#
boolean : 1byte#
----문자#
char : 2byte#
----정수형#
byte : 1byte#
short : 2byte#
int : 4byte#
long : 8byte#
----실수형#
float : 4byte#
double : 8byte#
^
#
1. 연산자 종류와 우선순위#
최우선연산자 > 단항연산자 > 이항연산자(산술연산자 > 쉬프트연산자 > 비교연산자 > 비트논리연산자 > 일반논리연산자#
> 삼항연산자 > 순수대입 > 산술대입 > 쉬프트대입 > 비트논리대입 > 나열연산자#

2. 단항연산자#
- 증감연산자(++, --)#
   전위연산 : 자신의 연산을 우선 실행 후 다음 연산#
   후위연산 : 자신이 속해 있는 연산을 먼저 실행 종료 후 자신의 연산 실행#
- 논리 부정 연산자(!) : 논리값을 부정하여 반대 값으로 변경한다. 제어문을 활용할 때 많이 쓰임#
3. 산술연산자 : *는 곱하기, /나누기의 몫을 %는 나누기의 나머지 값을 구하는 연산#
4. 비교 연산자 : 제어문에서 데이터를 비교(조건식)할때 자주 쓰임 결과값은 논리값(true, false) (a == b : a와 b가 같으면 true)#
5. 논리 연산자 #
   a&&b : a와 b 둘다 true 여야함#
   a || b : a 혹은 b 둘 중 하나만 true여도 가능#
6. 복합 대입 연산자 : 자기자신과 연산을 하고 연산한 결과를 자기자신에게 누적 대입#
   ex) A += 10 : A = A + 10 이랑 같은 의미#
7. 삼항연산자 : 조건식을 이용하여 결과값에 따라 연산을 처리하는 방식#
   조건식 ? true일때 실행 : false일때 실행#
^
1. 조건문#
- if 문 : 조건식의 결과 값이 true 면 { }안의 내용을 실행하고 false면 실행하지 않음#
ex ) if(조건식) {#
         ..... }#
- if ~ else문 :  조건식의 결과 값이 true면 if의 { }안의 내용을 실행하고 false면 else의{ }안의 내용을 실행#
ex ) if(조건식) {#
        ... } else {#
           ............ }#
- else if 문 : if의 조건식의 결과 값이 true면 { }안의 내용을 실행하고 false면 else if문의 조건식 검사 결과가 true면 { }실행 false면 else의 { }실행#
ex ) if(조건식) {#
         ....} else if(조건식) {#
         ................ #
         } else {#
         ......... }#
- switch 문 : 정수,문자,문자열에 있는 값(변수)이랑 일치한  (리터럴) case문을 실행, break를 만나면 switch를 빠져나감#
ex ) switch(변수(정수 or 문자 or 문자열))#
      {#
        case 리터럴(정수 or 문자 or 문자열) : ........ break;#
        case 리터럴(정수 or 문자 or 문자열) : ........ break;#
        default : .....................;#
      } #

2. 반복문#
- for 문 #
   - 1 회전 : 초기식 (1)확인 → 조건식 확인(2) true면 {}안 내용 1회 실행, false면 반복문 실행하지 않음#
   - 2회전 : 증감(3)연산 → 조건식(2)확인 true면 {}안 내용 1회 실행 false면 반복문 실행하지 않음#
   - 2회전 이상부터는 (2) → (3) 확인 후 조건식이 false가 나올 때까지 {}1번씩 실행#

ex) for(1.초기식; 2. 조건식; 3. 증감식) {#
            ......................#
        }#
- while문#
  - 조건식이 true일때 {}안 실행, false이 될 때까지 {}안에 내용 실행 #
  - {}실행이 끝나면 다시 조건식 확인 후 true면 재실행,  false일때 중단#
  - {}안에 조건을 벗어나게 할 연산이 있어야 함(증감식,분기문 등)#

ex) while(조건식) {#
       .................#
         [증감식 or 분기문];#
      }#

- do ~ while문#
  - do{}안의 내용 먼저 실행#
  - 조건식 확인 후 true면 {}안의 내용 실행, false면 실행 중단#
  - {}안에 조건을 벗어나게 할 연산이 있어야 함(증감식, 분기문 등)#
 
ex) [초기식]#
     do{#
         ................#
         [증감식 or 분기문];#
    } while(조건식);#

3. 분기문#
  - break : 반복문을 빠져나가는 구문 break 구문이 있는 곳에서 부터 반복문을 빠져 나옴#
  - continue : 반복문 실행시 continue 아래 부분은 실행하지 않고 반복문을 다시 실행(for문의 경우 증감식으로 이동)#
^
1. 배열이란? 동일한 자료 형들의 묶음, 반복문 사용이 가능해 데이터를 한번에 관리 가능#

2. 배열선언 #
   자료형 [ ] 변수이름;#
   자료형 변수이름 [ ];#

3. 배열의 할당#
   자료형 [ ] 변수이름 = new 자료형 [배열 크기];#
   자료형 변수이름 [ ] = new 자료형 [배열 크기];#

   -> new : 할당 연산자, heap 이라는 공간에 영역을 만들고 주소를 반환하는 연산자(heap : 주소로 찾아가는 영역)#

4. 배열의 길이#

- 배열의 길이를 알 수 있는 기능을 필드로 제공하고 있다.#
- 변수명.length 로 표기#
- 한번 지정한 배열의 크기는 변경하지 못한다.#
- 자료형[ ] 변수값 = new 자료형[ 크기 입력]#
  변수값 = new 자료형[크기 입력]#

5. 배열 복사#
얕은 복사 : 객체의 주소값만 가져와 참조형변수에 저장하고 하나의 객체를 두 변수가 참조하고 있는 것 #
- 방법 : int[] arr1 = new int[4] int[] arr2 = arr1;#
깊은 복사 : 다른 객체를 생성하여 새로운 객체에 데이터 내용을 복사하는 것 #
- 방법 : for문을 이용한 1:1복사 System.arraycopy() 메소드를 이용한 복사 clone() 메소드를 이용한 복사#

6. 정렬#
- 선택 정렬 : 소규모의 데이터를 정렬할때 빠름(모든 데이터 중에서 최소값을 찾아 앞에서 부터 차례로 채워 넣음)#
- 버블 정렬 : 인접한 두개의 데이터를 선택해 바꿀 상황이면 앞뒤로 바꿈(마지막에는 가장 최고값이 옴) → 이미 정렬되어 있는 데이터를 다시 정렬하므로 빨리 정렬됨 (역으로 정렬시 속도가 가장 느림)#
- 삽입 정렬 : 인덱스 하나씩 증가 시킬때마다 어느 위치에 삽입해야 하는지 값 비교 후 정렬 (버블정렬의 단점 보완), (작은 수를 빼서 비교후 삽입)#
^
1. 객체지향프로그램의 3대 특징#
- 캡슐화 : 추상화를 통해 정리된 데이터들과 기능을 하나로 묶어 관리하는 기법을말한다.#
- 상속#
- 다형성#


2. 클래스 선언#
[접근제한자] [예약어] class 클래스명{#
      자료형 변수명;#
      자료형 변수명;#


[접근제한자] 생성자명(){}#

[접근제한자]리턴형 메소드명(매개변수){#
	기능정의 }#
}#
}#


3. 변수의 종류#
1. 클래스변수 : static 영역에 저장되며 static키워드를 가짐.#
2. 멤버변수(인스턴스변수) : 클래스영역에 선언.#
3. 지역변수 : 클래스영역이 아닌, 메서드, 생성자, 초기화블럭내부에서 선언#

4. 접근제한자#
+ public : 전체 사용 가능#
# protected : 후손클래스내 사용가능#
~ (default) : 같은패키지내#
- private : 해당 클래스 내부#

5. 생성자란#
- 객체가 heap에 할당될 때 객체 안에서 만들어지는 필드의 초기화를 담당함.#
- new 할 때 실행되는 함수로 초기값을 생성자 함수의 인자로 전달함.#
- 생성자 함수가 전달된 매개변수를 받아서 필드에 값을 기록한다.#

6. 생성자의 종류#

1. 기본 생성자 (매개변수가 없는 생성자)#
- 작성하지 않은 경우, 클래스 사용시 JVM이 기본 생성자 자동 생성#

2. 매개변수 있는 생성자#
- 객체 생성시 전달 받은 값으로 객체를 초기화 하기 위해 사용함#
- 매개변수 있는 생성자 작성시 JVM이 기본 생성자 자동 생성 하지 않음#
- 상속에 사용시 반드시 기본 생성자를 작성해야 함#
- 오버로딩을 이용하여 작성함#

7. this란#
모든 인스턴스의 메소드에 숨겨진 채 존재하는 레퍼런스로, 할당된 객체를#
가르킨다. 해당 객체의 주소 값을 담고 있다#
^
1. 상속이란 ?#
다른 클래스가 가지고 있는 멤버(필드와 메소드)들을 새로 작성할#
클래스에서 직접 만들지 않고, 상속을 받음으로써 새 클래스가 자신의#
멤버처럼 사용할 수 있게 만든 기술#

2. 상속의 장점#
1. 보다 적은 양의 코드로 새로운 클래스를 작성 가능#
2. 코드를 공통적으로 관리하기 때문에 코드의 추가 및 변경이 용이함#
3. 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여함#

3. 작성방법#
[접근제한자] class 클래스명 extends 클래스명{}#
	         상속받는 클래스   상속하는 클래스#
                         후손 클래스          상위클래스#
                         자식 클래스          부모클래스#
                         파생 클래스          선조클래스#
                      서브(sub)클래스    슈퍼클래스#

4. 상속의 특징#
1. 부모클래스의 생성자, 초기화블럭은 상속 안됨 #
- 후손클래스 객체 생성시, 부모클래스 생성자가 먼저 실행되도록 되어 있음.#
- 후손클래스 생성자 안에서 부모클래스 생성자 호출을 명시하고 싶으면 super();를 입력함 #
2.  부모의 private 멤버는 상속은 되지만 접근 불가능 #
- 후손 객체 생성시에 부모의 필드값도 전달받은 경우, 후손 생성자 안에서 부모의 private 필드에 직접 초기값 대입 못함#
- 전달받은 부모 필드값을 부모생성자 쪽으로 넘기는 방법을 이용한다.#
예시) super(전달받을값, …);  //부모의 매개변수 있는 생성자를 통한 초기화 #
3. 모든 클래스는 Object 클래스의 후손 #
- Object클래스가 제공하는 메소드를 오버라이딩해서 메소드 본래 기능을 변경할 수 있음.#
예시) java.lang.String 클래스의 equals()과 toString()#

5. 오버라이딩#
후손 클래스가 상속받은 부모 메소드를 재작성하는 것을 말한다.#
부모가 제공하는 기능을 후손이 일부 고쳐 사용하겠다는 의미로, 후손#
객체를 통한 실행 시 후손 것이 우선권을 가진다.#

6. 오버라이딩의 성립요건#
- 이름이 동일해야 한다. #
- 매개변수의 개수와 타입, 순서가 동일해야 한다.#
- 리턴 타입이 동일해야 한다. #
- private 메소드의 오버라이딩은 불가하다.#
^

1. 다형성이란#
상속을 이용한 기술로, 부모 타입으로부터 파생된 여러 가지 타입을 하나의 타입인 것 처럼 처리할 수 있다.#

2. 클래스 형변환 ? up casting#
상속관계에 있는 부모, 자식 클래스 간에 부모타입의 참조형 변수가 모든 자식 타입의 객체의 주소를 받을 수 있다.#

예시) //Sonata클래스가 Car클래스의 후손임#
Car c = new Sonata();#
Sonata 클래스형 -> Car 클래스 형으로 바뀜#

3. 클래스 형변환 ? down casting#
자식객체의 주소를 받은 부모 참조형 변수를 가지고 자식의 멤버를 참조해야 할 경우,#
후손 클래스 타입으로 참조형 변수를 형 변환해야 한다. 이 변환을 down casting이라고 하며,#
자동으로 처리되지 않기 때문에 반드시 후손 타입을 명시해서 형 변환 해야 한다.#

예시) //Sonata클래스가 Car클래스의 후손임 #
        Car c = new Sonata(); #
        ((Sonata)c).moveSonata(); #

4. instance of란#
현재 참조형 변수가 어떤 클래스 형의 객체 주소를 참조하고 있는지 확인할 때 사용, #
클래스타입이 맞으면 true, 아니면 false값을 반환#

5. 동적바인딩이란?#
컴파일시 정적바인딩된 메소드를 실행할 당시의 객체 타입을 기준으로 바인딩 되는 것을 동적 바인딩이라고 한다.#

6. 동적바인딩 성립요건#
상속 관계로 이루어져 다형성이 적용된 경우에, #
메소드 오버라이딩이 되어 있으면 정적으로 바인딩 된 메소드 코드보다 #
오버라이딩 된 메소드 코드를 우선적으로 수행하게 된다.#

7. 인터페이스란?#
상수형 필드와 추상 메소드만을 작성할 수 있는 추상 클래스의 변형체이다. 메소드의 통일성을 부여하기 위해서 추상 메소드만 따로 모아 놓은것으로, 상속시 인터페이스 내에 정의된 모든 추상 메소드를 구현해야 한다.#

8. 인터페이스의 특징#
- 모든 인터페이스의 메소드는 묵시적으로 public이고 abstract이다.#
- 변수는 묵시적으로 public static final이다. -> 따라서 인터페이스 변수의 값 변경 시도는 컴파일시 에러를 발생 #
- 객체 생성은 불가, 참조형 타입으로서는 가능하다.#

9. 인터페이스의 상속#
Interface는 다중 상속을 지원하며 class가 상속을 받을 때에는#
implements라는 키워드를 사용한다.#
Interface간의 상속시에는 extends 키워드 사용 가능하고, 다중상속을#
지원한다.#
Interface 이용하여 단일 상속의 제한점을 극복할 수 있다.#

**표현식#
[접근제한자] interface인터페이스명 #
         extends 부모인터페이스명, 부모인터페이스명, …{} #
[접근제한자] class 클래스명 extends 부모클래스명 #
         implements 부모인터페이스명, 부모인터페이스명, …{}#

10.추상클래스란?#
몸체 없는 메소드(abstract가 있는 메소드)를 포함한 클래스 추상 클래스일 경우 #
클래스 선언부에 abstract 키워드를 사용#

11. 추상클래스의 특징#
- 미완성 클래스(abstract 키워드 사용)#
- abstract 메소드가 포함된 클래스 -> 반드시 abstract 클래스#
- 자체적으로 객체 생성 불가 -> 반드시 상속하여 객체 생성#
- 일반적인 메소드, 변수도 포함할 수 있다.#
- abstract메소드가 없어도 abstract 클래스 선언 가능하다.#
- 객체 생성은 안되나, ref변수 type으로는 사용 가능하다#
^

1. String 클래스#
문자열 값을 수정 못하는 immutable(불변)이다.#
수정 시 수정된 문자열이 새로 할당되어 새 주소를 넘긴다.#

2. String Buffer 클래스#
문자열 값을 수정할 수 있는 mutable(가변)이다.#
기존 문자열에 수정되어 적용된다.(수정, 삭제 등)#
기본 16문자 크기로 지정된 버퍼를 이용하며, 크기를 증가시킬 수 있다.#
쓰레드 safe 기능을 제공한다.(성능저하요인)#

3. StringBuilder 클래스#
String Buffer와 동일함#
쓰레드 safe기능을 제공하지 않음#

4. 오토박싱(Auto Boxing)#
기본자료형 → Wrapper클래스 변환#

5. 오토언박싱(Auto Unboxing)#
Wrapper클래스 → 기본자료형변환 #

6. Date 클래스#
시스템으로부터 현재 날짜, 시간 정보를 가져와서 다룰 수 있게 만들어진#
클래스로, 생성자 2개만 사용 가능하고 나머지는 deprecated이다. #
Calendar 클래스 혹은 GregorianCalendar 클래스 사용 권장#

7. Calendar /Gregorian Calendar 클래스#
Calendar 클래스는 생성자가 protected이기 때문에 new를 통해 객체#
생성을 하지 못하고, getInstance()메소드를 통해 객체를 생성한다. #
GregorianCalendar는 Calendar클래스의 후손 클래스이며, 년, 월, 일, 시, #
분, 초 정보를 필드를 이용하여 다룰 수 있다.#

8. StringTokenizer 클래스#
String 클래스에서 제공하는 split()메소드와 같은 기능을 하는 클래스이다. #
생성시 전달받은 문자열을 구분자로 나누어 각 토큰에 저장한다.#
^

1. 오류(ERROR)의 종류#
- 컴파일 에러(Compile-Time Error) : 소스 상의 문법 Error.#
- 런타임 에러(Runtime Error : 입력 값이 틀렸거나, 배열의 인덱스 범위를 벗어났거나, 계산식의 오류 등으로 인해 발생함 #
- 논리 에러(Logical Error) : 문법상 문제가 없고, 런타임에러도 발생하지 않지만, 개발자의 의도대로 작동하지 않음.#
- 시스템에러(System Error) : 컴퓨터 오작동으로 인한 에러 -> 소스 구문으로 해결 불가#

2. 예외(Exception)의 종류#
- Unchecked Exception : Arithmetic Exception, NullPointer Exception, IndexOutOfBounds Exception#
 (Runtime Exception에 속하며 예외처리를 강제화 하지 않는다.)#
- Checked Exception : EOFException , FileNotFoundException#
 (예외처리를 강제화 한다.)#

3. RuntimeException 후손 클래스#
· ArithmeticException#
- 0으로 나누는 경우에 발생 #
- If문으로 먼저 나누는 수가 0인지를 검사해야 함#
· NullPointerException#
- Null인 ref.변수로 객체 멤버 참조 시도# 
- 객체를 사용하기 전에 ref.변수가 null인지 먼저 확인해야 함#
· NegativeArraySizeException#
- 배열 크기를 음수로 지정한 경우#
- 배열 size를 0보다 크게 지정해야 함#
· ArrayIndexOutOfBoundException#
- 배열의 index범위를 넘어서 참조하는 경우 #
- 배열이름.length를 써서 배열의 범위를 확인해야 함#
· ClassCastException#
- Cast연산자 사용시 타입 오류#
- Instanceof 연산자를 이용하여, 먼저 객체 타입을 확인 후 Cast연산해야 함#

4. Exception 처리 방법#
1. Exception 처리를 호출한 메소드에게 위임#
- 메소드 선언시 throws ExceptionName 문을 추가하여 호출한 상위 메소드에게 처리를 위임하여 해결한다. #
- 계속적으로 위임하면 main()까지 위임하게 되고, main()까지 가서도 예외처리가 되지 않는 경우 JVM이 비정상 종료된다.#
2. Exception을 발생한 곳에서 직접 처리#
- try~catch문을 이용하여 예외를 처리한다.#
- try : exception 발생할 가능성이 있는 코드를 try구문 안에 기술한다.#
- catch : try 구문에서 exception 발생시 해당하는 exception에 대한 처리를 기술한다. 여러 개의 exception처리가 가능하나, exception간의 상속관계를 고려해야 한다.# 
- finally : exception 발생 여부에 관계 없이, 꼭 처리해야 하는 logic은 finally 안에서 구현한다. 중간에 return문을 만나도 finally구문은 실행한다. 단, System.exit(0)를 만나면 무조건 프로그램을 종료한다. 주로 java.io, java.sql 패키지의 메소드 처리시 이용한다.#
^

1. 컬렉션이란?#
메모리 상에서 자료를 구조적으로 처리하는 방법을 자료 구조라 일겉는다.#
컬렉션 Collection은 자바에서 제공하는 자료구조를 담당하는 프레임워크이다.#

2. 자료구조란?#
데이터(자료)를 메모리에서 구조적으로 처리하는 방법론이다.#
- 단순구조 : 정수, 실수, 문자, 문자열#
- 선형구조 : 리스트, 연결리스트(단순연결리스트, 이중연결리스트,원형연결리스트), 스택, 큐, 덱#
- 비선형구조 : 트리(일반트리, 이진트리), 그래프(방향그래프, 무방향그래프)#
- 파일구조 : 순차파일, 색인파일, 직접파일#

3. 컬렉션의 장점#
1. 저장하는 크기의 제약이 없다.#
2. 추가, 삭제, 정렬 등의 기능처리가 간단하게 해결된다.#
- 자료를 구조적으로 처리하는 자료구조가 내장되어 알고리즘 구현이 필요 없다.#
3. 여러 타입을 저장할 수 있다.#
- 객체만 저장할 수 있기 때문에, 필요에 따라 기본 자료형을 저장해야 하는 경우 Wrapper 클래스를 사용한다.#

4. 컬렉션의 주요 인터페이스#
- Collection #
   - List 계열 : 순서를 유지하고 저장, 중복 저장 가능(ArrayList, Vector, LinkedList)#
   - Set 계열 : 순서를 유지하지 않고 저장, 중복 저장 안됨(HashSet, TreeSet)#
- Map 계열 : 키와 값의 쌍으로 저장, 키는 중복 저장 안됨(HashMap, Hashtable, TreeMap, Properties)#
